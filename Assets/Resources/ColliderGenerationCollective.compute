int totalObjects;
int totalPolyEntrances;
int totalVerts;
int maxPolys;
RWStructuredBuffer<uint> nonRepeatingEntranceIdsAndCounts;
RWStructuredBuffer<float2> allVerts;
RWStructuredBuffer<uint> startIndicesEntrances;
RWStructuredBuffer<uint> startIndicesVerts;
RWStructuredBuffer<uint2> spriteBounds;
RWTexture2DArray<float4> idTextures;
RWTexture2DArray<float4> outputDebugTex;
RWTexture2DArray<float> holeOutputTex;

RWStructuredBuffer<float> resolutionFactors;
RWTexture2DArray<float4> allTextures;
RWStructuredBuffer<uint> pixelCounts;
RWStructuredBuffer<uint> polyHoleResults;
Texture2DArray<float4> origTextures;
RWTexture2DArray<float2> pixelCountsOutput;

// Each #kernel tells which function to compile; you can have many kernels


float dist(float2 point1, float2 point2)
{
    return sqrt(((point1.x - point2.x) * (point1.x - point2.x)) + ((point1.x - point2.y) * (point1.y - point2.y)));
}

float DistanceBetweenPointAndLineSegment(float2 point1, float2 start, float2 end)
{
    if (start.x == end.x && start.y == end.y)
        return dist(point1, start);

    float2 v = end - start;
    float2 w = point1 - start;

    float c1 = dot(w, v);
    if (c1 <= 0) return dist(point1, start);

    float c2 = dot(v, v);
    if (c2 <= c1) return dist(point1, end);

    float b = c1 / c2;
    float2 pointOnLine = (start + (v * b));
    return dist(point1, pointOnLine);
}

int EvaluateIDTex(uint3 coord)
{
    return ((int)round(idTextures[coord].r * 255) + (int)round(idTextures[coord].g * 255) + (int)round(idTextures[coord].b * 255) + (int)round(idTextures[coord].a * 255)) - 2;
}

#pragma kernel GetPixelCountsAndTextures

[numthreads(32,8,1)]
void GetPixelCountsAndTextures (uint3 id: SV_DispatchThreadID)
{
    uint yLevel = id.x;
    uint objIndex = id.y;
    if(yLevel > spriteBounds[objIndex].y)
    {
        return;
    }
    if(objIndex > totalObjects)
    {
        return;
    }
    uint width = spriteBounds[objIndex].x;
        
    int mostRecentID = -1;
    for(uint x = 0;x < width;x++)
    {
        if(EvaluateIDTex(uint3(x, yLevel, objIndex)) != -1 && EvaluateIDTex(uint3(x, yLevel, objIndex)) != -2)
        {
            mostRecentID = EvaluateIDTex(uint3(x, yLevel, objIndex));
        }
        if(EvaluateIDTex(uint3(x, yLevel, objIndex)) != -2 && mostRecentID != -1)
        {
            //resultDebug[yLevel * texWidth * resolutionFactor + x] = polyHoleResults[mostRecentID] + 1;
            for(int x1 = 0;x1 < (1/resolutionFactors[objIndex]);x1++)
            {
                for(int y1 = 0;y1 < (1/resolutionFactors[objIndex]);y1++)
                {
                    allTextures[uint3(x * (1/resolutionFactors[objIndex]) + x1, yLevel * (1/resolutionFactors[objIndex]) + y1, startIndicesVerts[objIndex] + polyHoleResults[startIndicesVerts[objIndex] + mostRecentID])] = origTextures[uint3((x * (1/resolutionFactors[objIndex]) + x1), (yLevel * (1/resolutionFactors[objIndex]) + y1), objIndex)];
                }
            }
            InterlockedAdd(pixelCounts[startIndicesVerts[objIndex] + polyHoleResults[startIndicesVerts[objIndex] + mostRecentID]], (1/resolutionFactors[objIndex]) * (1/resolutionFactors[objIndex]));
        }
    }
    for(int i = startIndicesVerts[objIndex];i < startIndicesVerts[objIndex + 1];i++)
    {
        int toRepresent = pixelCounts[i];
        int first = (toRepresent % 65536.0);
        int second = (int)(toRepresent/65536.0);
        pixelCountsOutput[uint3(i - startIndicesVerts[objIndex], 0, objIndex)] = float2(first/65536.0, second/65536.0);
    }
}

#pragma kernel FindHolesViaVerticesCollective

[numthreads(8,8,1)]
void FindHolesViaVerticesCollective (uint3 id : SV_DispatchThreadID)
{
    int polyIndex = id.y;
    if(polyIndex >= maxPolys)
    {
        //holeOutputTex[uint3(polyIndex, 0, objectIndex)] = float((id.x + 1)/65535.0);
        return;
    }
    int objectIndex = id.x;
    //debugIntBuffer[id.x * maxPolys + id.y] = objectIndex;
    //holeOutputTex[uint3(polyIndex, 0, objectIndex)] = float((id.x + 1.0)/65535.0);
    if(objectIndex >= totalObjects)
    {
        return;
    }
    if(startIndicesVerts[objectIndex] + polyIndex > startIndicesVerts[objectIndex + 1] - 1)
    {
        holeOutputTex[uint3(polyIndex, 0, objectIndex)] = float((polyIndex + 1)/65535.0);
        return;
    }
    
    
    int startEntranceID = startIndicesEntrances[objectIndex] + (polyIndex * sqrt(startIndicesVerts[objectIndex + 1] - startIndicesVerts[objectIndex]));
    /*if(polyIndex == 0)
    {
        for(int x = 0;x < spriteBounds[objectIndex].x;x++)
        {
            for(int y = 0;y < spriteBounds[objectIndex].y;y++)
            {
                int eval = EvaluateIDTex(uint3(x,y,objectIndex));
                if(eval == 0)
                {
                    outputDebugTex[uint3(x,y,objectIndex)] = float4(1.0,0.0,0.0,1.0);
                }else if(eval == 1)
                {
                    outputDebugTex[uint3(x,y,objectIndex)] = float4(1.0,0.0,1.0,1.0);
                }
                else if(eval == 2)
                {
                    outputDebugTex[uint3(x,y,objectIndex)] = float4(1.0,1.0,0.0,1.0);
                }else if(eval == 3)
                {
                    outputDebugTex[uint3(x,y,objectIndex)] = float4(0.0,1.0,1.0,1.0);
                } else if(eval == 4)
                {
                    outputDebugTex[uint3(x,y,objectIndex)] = float4(0.5,0.0,1.0,1.0);
                }else if(eval == -2)
                {
                    outputDebugTex[uint3(x,y,objectIndex)] = float4(0.3,0.3,0.3,1.0);
                }else if(eval == -1)
                {
                    outputDebugTex[uint3(x,y,objectIndex)] = float4(0.5,0.5,0.5,1.0);
                }
                
            }
        }
    }*/
    uint startX = allVerts[startIndicesVerts[objectIndex] + polyIndex].x;
    uint y = allVerts[startIndicesVerts[objectIndex] + polyIndex].y;
    uint insideTotal = 0;
    uint totalLines = 0;
    int width = spriteBounds[objectIndex].x;
    for(uint x = startX; x < width;x++)
    {
        if(EvaluateIDTex(uint3(x,y,objectIndex)) != -1 && EvaluateIDTex(uint3(x,y,objectIndex)) != -2 && (EvaluateIDTex(uint3(x - 1,y,objectIndex)) == -2 || EvaluateIDTex(uint3(x + 1,y,objectIndex)) == -2) && EvaluateIDTex(uint3(x,y,objectIndex)) != polyIndex)
        {
            //outputDebugTex[uint3(x,y,objectIndex)] = float4(0.0,1.0,0.0,1.0);
            uint currentInd = EvaluateIDTex(uint3(x,y,objectIndex));
            bool newPoly = true;
            uint polyInd = -1;
            for(int i = 0;i < insideTotal;i++)
            {
                if(nonRepeatingEntranceIdsAndCounts[startEntranceID + i] == currentInd)
                {
                    newPoly = false;
                    polyInd = i;
                    break;
                }
            }
            if(newPoly)
            {
                polyInd = insideTotal;
                nonRepeatingEntranceIdsAndCounts[startEntranceID + polyInd] = currentInd;
                insideTotal += 1;
            }
            if(EvaluateIDTex(uint3(x - 1,y,objectIndex)) == -2 && EvaluateIDTex(uint3(x + 1,y,objectIndex)) == -2)
            {
                //outputDebugTex[uint3(x,y,objectIndex)] = float4(1.0,0.0,0.0,1.0);
                nonRepeatingEntranceIdsAndCounts[totalPolyEntrances + startEntranceID + polyInd] += 2; //count
                totalLines += 2;
            }else
            {
                //outputDebugTex[uint3(x,y,objectIndex)] = float4(1.0,0.0,1.0,1.0);
                nonRepeatingEntranceIdsAndCounts[totalPolyEntrances + startEntranceID + polyInd] += 1; //count
                totalLines += 1;
            }
        }
    }
    bool isHole = false;
    if(totalLines % 2 == 1)
    {
        for(int i = 0;i < insideTotal;i++)
        {
            if(nonRepeatingEntranceIdsAndCounts[totalPolyEntrances + startEntranceID + i] % 2 == 1) //count
            {
                isHole = true;
                //outputDebugTex[uint3(startX,y,objectIndex)] = float4(0.0,1.0,0.0,1.0);
                //outputDebugTex[uint3(startX + 1,y,objectIndex)] = float4(0.0,1.0,0.0,1.0);
                //outputDebugTex[uint3(startX,y + 1,objectIndex)] = float4(0.0,1.0,0.0,1.0);
                //outputDebugTex[uint3(startX + 1,y + 1,objectIndex)] = float4(0.0,1.0,0.0,1.0);
                polyHoleResults[startIndicesVerts[objectIndex] + polyIndex] = nonRepeatingEntranceIdsAndCounts[startEntranceID + i];
                holeOutputTex[uint3(polyIndex, 0, objectIndex)] = float((nonRepeatingEntranceIdsAndCounts[startEntranceID + i] + 1.0)/65535.0);
                break;
            }
        }
    }
    if(!isHole)
    {
        holeOutputTex[uint3(polyIndex, 0, objectIndex)] = float((polyIndex + 1.0)/65535.0);
        polyHoleResults[startIndicesVerts[objectIndex] + polyIndex] = polyIndex;
    }
}
